import { HttpClientTestingModule } from '@angular/common/http/testing';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { MAT_DIALOG_DATA, MatDialog, MatDialogModule, MatDialogRef } from '@angular/material/dialog';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { Router } from '@angular/router';
import { RouterTestingModule } from '@angular/router/testing';
import { Game } from '@app/interfaces/game';
import { GameService } from '@app/services/game.service';
import { SnackbarService } from '@app/services/snackbar.service';
import { SocketService } from '@app/services/socket.service';
import { of } from 'rxjs';
import { AdminPageComponent } from './admin-page.component';

const mockData = {
    id: '1zkjdm',
    title: 'VISIBILITY TEST',
    description: 'asdfasdfasdfasd',
    duration: 10,
    lastModification: new Date('2024-02-12T14:48:55.329Z'),
    questions: [
        {
            type: 'QCM',
            text: 'test retour',
            points: 10,
            lastModification: new Date('2024-02-12T14:48:55.329Z'),
            id: 'vdkp2a',
            choices: [
                { text: 'ca marche', isCorrect: true },
                { text: 'ou pas', isCorrect: false },
            ],
        },
        {
            type: 'QCM',
            text: ' cv',
            points: 10,
            lastModification: new Date('2024-02-12T14:48:55.329Z'),
            id: 'fjfdl1',
            choices: [
                { text: 'c dvfb', isCorrect: true },
                { text: 'hola', isCorrect: true },
                { text: 'rghtyj', isCorrect: false },
            ],
        },
        {
            type: 'QCM',
            text: 'test2',
            points: 10,
            lastModification: new Date('2024-02-12T14:48:55.329Z'),
            id: 'jssar7',
            choices: [
                { text: 'cdcd==', isCorrect: true },
                { text: 'ouioui', isCorrect: true },
                { text: 'cdcd', isCorrect: false },
            ],
        },
        {
            type: 'QCM',
            text: 'Quelle est la capitale du Canada?',
            points: 10,
            lastModification: new Date('2024-02-05T00:58:28.573Z'),
            id: 'qrvbvo',
            choices: [
                { text: 'Toronto', isCorrect: false },
                { text: 'Ottawa', isCorrect: true },
            ],
        },
    ],
} as Game;

describe('AdminPageComponent', () => {
    let component: AdminPageComponent;
    let fixture: ComponentFixture<AdminPageComponent>;
    let router: Router;
    let snackbarServiceMock: jasmine.SpyObj<SnackbarService>;

    const matDialogMock = jasmine.createSpyObj('MatDialog', ['open', 'afterClosed']);
    const gameServiceMock = jasmine.createSpyObj('gameService', [
        'patchGame',
        'getGames',
        'deleteGame',
        'getGame',
        'createGame',
        'validateDuplicationGame',
    ]);
    const socketServiceMock = jasmine.createSpyObj('socketService', ['connect']);
    const dialogMock = {
        open: () => {
            return { afterClosed: () => of(true) };
        },
    };

    beforeEach(async () => {
        snackbarServiceMock = jasmine.createSpyObj('SnackbarService', ['openSnackBar']);

        await TestBed.configureTestingModule({
            declarations: [AdminPageComponent],
            imports: [HttpClientTestingModule, MatSnackBarModule, RouterTestingModule, MatDialogModule],
            providers: [
                {
                    provide: GameService,
                    useValue: gameServiceMock,
                },
                { provide: SnackbarService, useValue: snackbarServiceMock },
                {
                    provide: SocketService,
                    useValue: socketServiceMock,
                },
                { provide: MatDialogRef, useValue: dialogMock },
                { provide: MatDialog, useValue: matDialogMock },
                { provide: MAT_DIALOG_DATA, useValue: {} },
            ],
        }).compileComponents();

        fixture = TestBed.createComponent(AdminPageComponent);
        component = fixture.componentInstance;
        router = TestBed.inject(Router);
        spyOn(router, 'navigate');
        fixture.detectChanges();
        component.dataSource = [mockData as Game];
    });

    it('should create', () => {
        expect(component).toBeTruthy();
    });

    it("should populate dataSource with games' data", async () => {
        gameServiceMock.getGames.and.returnValue(Promise.resolve([mockData]));
        await component.ngOnInit();
        expect(component.dataSource).toEqual([mockData]);
    });

    it('should toggle visibility', () => {
        gameServiceMock.patchGame.and.returnValue(Promise.resolve());
        component.toggleVisibility('1zkjdm', true);
        expect(gameServiceMock.patchGame).toHaveBeenCalled();
    });

    it('should call importGamesFromFile when onFileSelected is called', () => {
        const event = {
            target: {
                files: [{ name: 'test' }],
            },
        } as unknown as Event;
        const spy = spyOn(component, 'importGamesFromFile');
        component.onFileSelected(event);
        expect(spy).toHaveBeenCalled();
    });

    it('should call getGameTitle when getValidGameTitle is called', async () => {
        const spy = spyOn(component, 'getValidGameTitle');
        await component.getValidGameTitle(mockData);
        expect(spy).toHaveBeenCalled();
    });

    it("should delete unwanted fields from game's json", () => {
        const game = { ...mockData, _id: '1', isVisible: true };
        gameServiceMock.patchGame.and.returnValue(Promise.resolve());
        const result = component['removeUnwantedFields'](game);
        expect(result).toEqual(mockData);
    });

    it('should navigate to create-qgame when createGame is called', () => {
        component.createGame();
        expect(router.navigate).toHaveBeenCalledWith(['/create-qgame']);
    });

    it('should format date string correctly in French Canadian format', () => {
        expect(component.formatLastModificationDate('2024-02-12T14:48:55.329Z')).toEqual('2024-02-12 14 h 48');
    });

    it('should delete a game when confirmed', async () => {
        gameServiceMock.deleteGame.and.returnValue(Promise.resolve());
        matDialogMock.open.and.returnValue({ afterClosed: () => of(true) });
        await component.deleteGame('1zkjdm');

        expect(gameServiceMock.deleteGame).toHaveBeenCalled();
    });

    it("should check in dataSource if game's title already exists", () => {
        expect(component['isGameNameUnique']('VISIBILITY TEST')).toBeFalsy();
    });

    it("should check user input for game's title", () => {
        expect(component['hasValidInput']('1111111111111111111111111111111111', mockData.title)).toBeFalsy();
        expect(component['hasValidInput']('VISIBILITY TEST', mockData.title)).toBeTrue();
        expect(component['hasValidInput']('', mockData.title)).toBeTrue();
        expect(component['hasValidInput']('VISIBILITY TEST', '')).toBeTrue();
    });

    it("should prepare game's json for import", () => {
        const game = { ...mockData, idNewGame: '1bn3C' };
        component['prepareGameForImport'](game);
        expect(game.idNewGame).toBe('1bn3C');
    });

    it("should validate game's title", async () => {
        const spy = spyOn(component, 'getValidGameTitle');
        await component.getValidGameTitle(mockData);
        expect(spy).toHaveBeenCalled();
    });

    it('should return a new valid game title immediately', async () => {
        matDialogMock.open.and.returnValue({
            afterClosed: () => of('New Valid Title'),
        });

        const originalGame = { title: 'Original Game Title' } as Partial<Game>;
        const newTitle = await component.getValidGameTitle(originalGame as Game);

        expect(newTitle).toEqual('New Valid Title');
        expect(matDialogMock.open).toHaveBeenCalled();
    });

    it('should handle cancellation', async () => {
        matDialogMock.open.and.returnValue({
            afterClosed: () => of(null),
        });

        const originalGame = { title: 'Original Game Title' } as Partial<Game>;
        const newTitle = await component.getValidGameTitle(originalGame as Game);

        expect(newTitle).toBeNull();
        expect(matDialogMock.open).toHaveBeenCalled();
    });

    it('should handle empty string', async () => {
        matDialogMock.open.and.returnValue({
            afterClosed: () => of(''),
        });

        const originalGame = { title: 'Original Game Title' } as Partial<Game>;
        const newTitle = await component.getValidGameTitle(originalGame as Game);

        expect(newTitle).toBeNull();
        expect(matDialogMock.open).toHaveBeenCalled();
    });
});
